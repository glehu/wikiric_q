/*
 * Copyright (c) 2024.
 * Module wikiric-utils.js of wikiricQ or wikiric including wikiric and wikiricGo
 * themselves were, are and remain intellectual property of Luca Goldhausen.
 * You may use, edit and redistribute any of their parts as long as you give credit
 * in some visually accessible way.
 * (where one would expect it without having to be visible on a screen under heavy use by the viewer).
 */

const wikiricUtils = {
  /**
   * Converts an HTML document to a human-readable string
   *
   * @param html
   * @returns {string}
   */
  htmlToString: function (html) {
    const dParser = new DOMParser()
    const parsed = dParser.parseFromString(html, 'text/html')
    const elem = parsed.documentElement
    const strArray = []
    let type
    let level
    let prefix
    let str
    let str2
    let len
    elem.childNodes.forEach((c) => {
      if (c.childNodes && c.childNodes.length > 0) {
        c.childNodes.forEach((cc) => {
          type = this.htmlTagNameToType(cc.tagName)
          switch (type) {
            case 'heading':
              prefix = ''
              level = this.htmlGetHeadingLevel(cc.tagName)
              if (level) {
                for (let i = 0; i < level; i++) {
                  prefix += '#'
                }
              }
              str = `${prefix} ${cc.innerText}`
              str2 = ''
              len = parseInt((str.length * 1.4).toString())
              for (let i = 0; i < len; i++) {
                str2 += '_'
              }
              strArray.push(`\n \n${str}\n${str2}`)
              break
            case 'line':
              strArray.push('---')
              break
            case 'blockquote':
              this._htmlParseChildNodes(cc, strArray, type)
              break
            case 'list':
              this._htmlParseChildNodes(cc, strArray, type)
              break
            default:
              strArray.push(cc.innerText)
          }
        })
      }
    })
    return strArray.join('\n').trim()
  },
  /**
   *
   * @param {ChildNode} c
   * @param {Array<String>} strArray
   * @param {String} parentType
   * @private
   */
  _htmlParseChildNodes: function (c, strArray, parentType) {
    let str
    c.childNodes.forEach((cc) => {
      const type = this.htmlTagNameToType(cc.tagName)
      str = ''
      switch (type) {
        case 'list' || 'blockquote':
          // Recursively call function to add each list item individually
          this._htmlParseChildNodes(cc, strArray, type)
          break
        case 'listitem':
          strArray.push(`* ${cc.innerText}`)
          break
        default:
          if (parentType === 'blockquote') {
            str = '[!] ' // Prepend exclamation mark
            parentType = '' // Cancel operation after first one
          }
          str += `${cc.innerText}`
          strArray.push(str)
      }
    })
  },
  /**
   * Converts an HTML element's tag name (e.g. H1)
   * ...to its type (e.g. heading)
   *
   * @param {String} tagName
   * @returns {string}
   */
  htmlTagNameToType: function (tagName) {
    if (tagName == null || tagName === '') {
      return ''
    }
    // Sanitize
    tagName = tagName.toLowerCase()
    // Check and return type
    const headingMatches = tagName.match(/h[1-6]/)
    if (headingMatches && headingMatches.length > 0) {
      return 'heading'
    } else if (tagName === 'p') {
      return 'paragraph'
    } else if (tagName === 'span') {
      return 'span'
    } else if (tagName === 'blockquote') {
      return tagName
    } else if (tagName === 'hr') {
      return 'line'
    } else if (tagName === 'code') {
      return tagName
    } else if (tagName === 'pre') {
      return 'code'
    } else if (tagName === 'ul' || tagName === 'ol') {
      return 'list'
    } else if (tagName === 'li') {
      return 'listitem'
    }
  },
  /**
   *
   * @param {String} tagName
   */
  htmlGetHeadingLevel: function (tagName) {
    // Sanitize
    tagName = tagName.toLowerCase()
    const headingMatches = [...tagName.matchAll(/h([1-6])/gm)]
    if (headingMatches && headingMatches.length > 0) {
      return headingMatches[0][1]
    }
  },
  /**
   * getUUID generates a unique ID to be used internally.
   *
   * Real UUIDs for data entries should be generated by the wikiric backend.
   *
   * @return {String}
   */
  getUUID: function () {
    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
    )
  },
  wasmBrowserInstantiate: async function (wasmModuleUrl, importObject) {
    let response
    // Check if the browser supports streaming instantiation
    if (WebAssembly.instantiateStreaming) {
      // Fetch the module, and instantiate it as it is downloading
      response = await WebAssembly.instantiateStreaming(
        fetch(wasmModuleUrl),
        importObject
      )
    } else {
      // Fallback to using fetch to download the entire module
      // And then instantiate the module
      const fetchAndInstantiateTask = async () => {
        const wasmArrayBuffer = await fetch(wasmModuleUrl).then(response =>
          response.arrayBuffer()
        )
        return WebAssembly.instantiate(wasmArrayBuffer, importObject)
      }
      response = await fetchAndInstantiateTask()
    }
    return response
  }
}
export default wikiricUtils
